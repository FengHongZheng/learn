### mysql 45讲

> #### 第 1 讲

1. server层，包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 
   * 连接器，负责跟客户端建立连接、获取权限、维持和管理连接。 （长连接问题）
   * 查询缓存 ，不推荐使用。
   * 分析器，分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句， MySQL需要识别出里面的字符串分别是什么，代表什么；做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 
   * 优化器，经过了分析器， MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。
     优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时
     候，决定各个表的连接顺序。 
   * 执行器，MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误； 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。  
   
   ```
   在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的。
   ```
   
2. 存储引擎，负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、 MyISAM、 Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 





> #### 第 2 讲

1. redo log（重做日志）
   * 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时， InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
   *  InnoDB的redo log是固定大小的 。
   * 有了redo log， InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力
     称为crash-safe 。
   * redo log是InnoDB引擎特有的日志 。
   
2. binlog（归档日志）
   
   * binlog是MySQL的Server层实现的，所有引擎都可以使用（binlog没有crash-safe能力）。
   
3. redo log和binlog区别

   * redo log是InnoDB引擎特有的； binlog是MySQL的Server层实现的，所有引擎都可以使用。
   * redo log是物理日志，记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志，记录的是这
     个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 
   * redo log是循环写的，空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一
     定大小后会切换到下一个，并不会覆盖以前的日志。 

4. update时候的内部流程（update table1 set value = value + 1 where id = 2）

   * 执行器先找引擎取ID=2这一行。 ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在
     的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

   * 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，
     再调用引擎接口写入这行新数据。

   * 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处
     于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

   * 执行器生成这个操作的binlog，并把binlog写入磁盘。

   * 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完
     成。 

   ```
   redo log的写入被拆成了两个步骤： prepare和commit，这就是"两阶段提交"。
   mysql还有回滚日志（undo log）,错误日志（error log）,慢查询日志（slow query log）等等。
   ```

5. [关于日志的更详细的解释](https://www.cnblogs.com/wy123/p/8365234.html)



> #### 第 3 讲

1. 事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务（这也是MyISAM被InnoDB取代的重要原因之一）。 

2. ACID，原子性，一致性，隔离性，持久性。

3. 隔离性：为了解决数据库上有多个事务同时执行的时候可能出现脏读（dirty read）、不可重复读（nonrepeatable read）、幻读（phantom read）的问题，就有了隔离级别的概念。SQL标准的事务隔离级别包括：<b>读未提交</b>（read uncommitted）、<b>读提交</b>（read committed）、<b>可重复读</b>（repeatable read）和<b>串行化</b>（serializable ）。 

   * 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
   * 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
   * 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
     当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
   * 串行化，顾名思义是对于同一行记录， “写”会加“写锁”， “读”会加“读锁”。当出现读写锁冲突的时
     候，后访问的事务必须等前一个事务执行完成，才能继续执行。

   ```
   在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是， “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
   Oracle数据库的默认隔离级别其实就是“读提交”。
   ```


4. 事务隔离的实现（回滚日志，长事务，可以在information_schema库的innodb_trx这个表中查询长事务）

5. 事务的启动方式

   

> #### 第 4 讲

1. 索引，在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工
   作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。 
2. 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的， InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每一个索引在InnoDB里面对应一棵B+树。 
3. 根据叶子节点的内容，索引类型分为主键索引和非主键索引。
   主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
   非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。 
4. 基于主键索引和普通索引的查询的区别：主键查询方式，则只需要搜索主键这棵B+树；普通索引查询方式，则需要先搜索k索引树，得到主键的值，再到主键索引树搜索一次。这个过程称为<b>回表</b>。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。  





